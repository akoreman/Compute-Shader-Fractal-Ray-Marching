
#pragma kernel CSMain
#pragma multi_compile __ CAST_SHADOWS
#pragma multi_compile __ LIT_SHADING
#pragma multi_compile __ AMBIENT_OCCLUSION

// These are set from RayMarcher.cs /////////
Texture2D<float4> Source;
RWTexture2D<float4> Target;

float4x4 _CameraToWorldProj;
float4x4 _CameraInverseProj;

float4 _CameraPosition;
float4 _CameraRotation;
////////////////////////////////////////

#include "Folds.hlsl"
#include "DistanceEstimators.hlsl"
#include "Fractals.hlsl"

static const float epsilon = 0.001;
static const float maxMarchDistance = 250;
static const int maxNumMarchSteps = 250;

static const float ambOccFudgeFactor = 50;
static const float castShadowFactor = 0.25;

static const float3 lightDirection = normalize(float3(0.6, 0.5, 0.1));
//float lightWidth = .01;

struct Ray
{
	float3 Origin;
	float3 Direction;
	float closestPoint;
};

Ray CreateRay(float3 Origin, float3 Direction)
{
	Ray ray;

	ray.Origin = Origin;
	ray.Direction = Direction;
	ray.closestPoint = 100000;

	return ray;
}

Ray CreateCameraRay(float2 xy)
{
	//float3 Origin = mul(_CameraToWorldProj, float4(0,0,0,1)).xyz;
	float3 Origin = _CameraPosition.xyz;

    float3 Direction = mul(_CameraInverseProj, float4(xy,0,1)).xyz;
    Direction = mul(_CameraToWorldProj, float4(Direction,0)).xyz;
    Direction = normalize(Direction);

	return CreateRay(Origin,Direction);
}

// Source: https://www.iquilezles.org/www/articles/normalsSDF/normalsSDF.htm
float3 ApproxNormal(float3 Position, float dx)
{
	float3 normalVec = float3(0, 0, 0);

	normalVec.x = mengerBox(Position + float3(dx, 0, 0));
	normalVec.x -= mengerBox(Position - float3(dx, 0, 0));

	normalVec.y = mengerBox(Position + float3(0, dx, 0));
	normalVec.y -= mengerBox(Position - float3(0, dx, 0));

	normalVec.z = mengerBox(Position + float3(0, 0, dx));
	normalVec.z -= mengerBox(Position - float3(0, 0, dx));
	
	/*
	normalVec.x = infiniteShapes(Position + float3(dx, 0, 0));
	normalVec.x -= infiniteShapes(Position - float3(dx, 0, 0));

	normalVec.y = infiniteShapes(Position + float3(0, dx, 0));
	normalVec.y -= infiniteShapes(Position - float3(0, dx, 0));

	normalVec.z = infiniteShapes(Position + float3(0, 0, dx));
	normalVec.z -= infiniteShapes(Position - float3(0, 0, dx));
	*/
	return normalize(normalVec);
}


[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	Target[id.xy] = Source[id.xy];

	uint width,height;
    Target.GetDimensions(width, height);

	float marchDistance = 0;
	int numMarchSteps = 0;

	//Convert from coordinates [-width,width] and [-heigth,height] to [-1,1] and [-1,1].
	float2 uv = id.xy / float2(width,height) * 2 - 1;

    Ray cameraRay = CreateCameraRay(uv);
	bool hit = false;

	Target[id.xy] = float4(0,1,1,0);

	while (marchDistance < maxMarchDistance && numMarchSteps < maxNumMarchSteps)
	{
		numMarchSteps++;

		///// FUNCTIONAL FRACTALS ///////
		float minDistance = mengerBox(cameraRay.Origin);
		//float minDistance = sierpinskiTetrahedron(cameraRay.Origin);
		//float minDistance = infiniteShapes(cameraRay.Origin);
		//////////////////////////////////

		//float minDistance = treePlanet(cameraRay.Origin);
		//float minDistance = mandelBox(cameraRay.Origin);
		//float minDistance = butterweedHills(cameraRay.Origin);

		if (minDistance < cameraRay.closestPoint) {cameraRay.closestPoint = minDistance;}

		float light = 1;
		float lighting = 1;

		if (minDistance < epsilon)
		{
			hit = true;

#if AMBIENT_OCCLUSION
			light = 1 -  (float)numMarchSteps / ambOccFudgeFactor;
#endif

#if LIT_SHADING
			lighting = dot(ApproxNormal(cameraRay.Origin, 0.00001),lightDirection);
#endif

			Target[id.xy] = light * lighting * float4(1, 0, 0, 0);
			
#if CAST_SHADOWS

			Ray lightRay = CreateRay(cameraRay.Origin - 10 * epsilon * cameraRay.Direction, lightDirection );

			float lightMarchDistance = 0;
			int ligthNumMarchSteps = 0;

			while (lightMarchDistance < maxMarchDistance && ligthNumMarchSteps < maxNumMarchSteps)
			{
				ligthNumMarchSteps++;

				float minLightDistance = mengerBox(lightRay.Origin);
				//float minLightDistance = treePlanet(lightRay.Origin);
				//float minLightDistance = infiniteShapes(lightRay.Origin);

				if (minLightDistance < epsilon)
				{
					Target[id.xy] *= castShadowFactor;
					break;
				}

				lightMarchDistance += minLightDistance;
				lightRay.Origin += lightRay.Direction * minLightDistance;
			}
			
#endif

			break;
		}
	
		marchDistance += minDistance;
		cameraRay.Origin += cameraRay.Direction * minDistance;
	}

	if (!hit)
	{
		float4 Glow = max((1 - cameraRay.closestPoint/.05 ) * float4(1,1,0,0), 0);
		Target[id.xy] += Glow;
	}

}
