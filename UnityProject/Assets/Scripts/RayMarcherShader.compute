// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// These are set from RayMarcher.cs /////////
Texture2D<float4> Source;
RWTexture2D<float4> Target;

float4x4 _CameraToWorldProj;
float4x4 _CameraInverseProj;

float4 _CameraPosition;
float4 _CameraRotation;
////////////////////////////////////////

static const float epsilon = 0.01;
static const float maxMarchDistance = 25;
static const int maxNumMarchSteps = 25;

float power = 1.5;

struct Ray
{
	float3 Origin;
	float3 Direction;
	float closestPoint;
};

Ray CreateRay(float3 Origin, float3 Direction)
{
	Ray ray;

	ray.Origin = Origin;
	ray.Direction = Direction;
	ray.closestPoint = 100000;

	return ray;
}

Ray CreateCameraRay(float2 xy)
{
	//float3 Origin = mul(_CameraToWorldProj, float4(0,0,0,1)).xyz;
	float3 Origin = _CameraPosition.xyz;

    float3 Direction = mul(_CameraInverseProj, float4(xy,0,1)).xyz;
    Direction = mul(_CameraToWorldProj, float4(Direction,0)).xyz;
    Direction = normalize(Direction);

	return CreateRay(Origin,Direction);
}

/*
float2 SceneInfo(float3 position) 
{
    float3 z = position;
	float dr = 1.0;
	float r = 0.0;
    int iterations = 0;

	for (int i = 0; i < 15 ; i++) {
        iterations = i;
		r = length(z);

		if (r>2) 
		{
            break;
        }
        
		// convert to polar coordinates
		float theta = acos(z.z/r);
		float phi = atan2(z.y,z.x);
		dr =  pow( r, power-1.0)*power*dr + 1.0;

		// scale and rotate the point
		float zr = pow( r,power);
		theta = theta*power;
		phi = phi*power;
		
		// convert back to cartesian coordinates
		z = zr*float3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));
		z+=position;
	}

    float dst = 0.5*log(r)*r/dr;
	return float2(iterations,dst*1);
}
*/

float DETetraHedron(float3 Position)
{
	int Iterations = 12;
	float Scale = 2;
	float3 a1 = float3(1, 1, 1);
	float3 a2 = float3(-1, -1, 1);
	float3 a3 = float3(1, -1, -1);
	float3 a4 = float3(-1, 1, -1);
	float3 c;
	int n = 0;
	float dist, d;
	while (n < Iterations) {
		c = a1;
		dist = length(Position - a1);
		d = length(Position - a2);
		if (d < dist) { c = a2; dist = d; }
		d = length(Position - a3);
		if (d < dist) { c = a3; dist = d; }
		d = length(Position - a4);
		if (d < dist) { c = a4; dist = d; }
		Position = Scale * Position - c * (Scale - 1.0);
		n++;
	}


	return length(Position) * pow(Scale, float(-n));
}

float DESphere(float3 Position)
{
	float3 Center = float3(.5,.5,.5);
	float Radius = 0.3;

	float modulo = 2;

	//float s = sin (3.6);
	//float c = cos (3.6);

	//Position = abs(Position);

	/*
	Position.x = Position.x;// % modulo;
	Position.y = Position.y;// % modulo;
	Position.z = Position.z;// % modulo;
	*/

	//Position = abs (Position);
	float a = 1;

	//Position.x = abs( (Position.x - a/2) % a - a/2 );
	Position.x = fmod(Position.x, a);// -.5);
	Position.z = fmod(Position.z, a);// -.5);
	//Position.z = (fmod(Position.z , a));
	//Position.x = abs((Position.x) % a );

	//Position = fmod(Position, modulo);
	//Position = Position % modulo;

	//Position.y = (c*Position.y + s*Position.z);
	//Position.z = (c*Position.z - s*Position.y);

	/////////// ButterWeed Hills ////////////////
	int counter = 0;
	

	/*
	while (counter < 2)
	{
		counter++;
		Position = abs(Position);

		//Position *= 1.5;
		//Position.x -= 1.0;
		//Position.y -= 0.5;
		//Position.z -= 0.2;

		s = sin(3.61);
		c = cos(3.61);

		//Position.y = (c*Position.y + s*Position.z);
		//Position.z = (c*Position.z - s*Position.y);

		s = sin(2.03);
		c = cos(2.03);

		//Position.z = (c*Position.z + s*Position.x);
		//Position.x = (c*Position.x - s*Position.z);
	}
	*/
	//Position = abs(Position);
	
	float3 distanceVector = Position - Center;

	return max(0,( length(distanceVector) - Radius));
}

float DEBox( float3 Position, float3 b )
{
	float modulo = 10.0;
	Position = Position % modulo;

	float3 q = abs(Position) - b;
	return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}


float EstimateNormalSphere(float3 Position, float3 Center, float3 lightDirection)
{
	float3 Normal = Position - Center;
	return dot(Normal,lightDirection);
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	Target[id.xy] = Source[id.xy];

	uint width,height;
    Target.GetDimensions(width, height);

	float marchDistance = 0;
	int numMarchSteps = 0;

	//Convert from coordinates [-width,width] and [-heigth,height] to [-1,1] and [-1,1].
	float2 uv = id.xy / float2(width,height) * 2 - 1;

    Ray cameraRay = CreateCameraRay(uv);

	//float escapeIterations = 1;

	bool hit = false;

	Target[id.xy] = float4(0,1,1,0);

	while (marchDistance < maxMarchDistance && numMarchSteps < maxNumMarchSteps)
	{
		numMarchSteps++;
		//ADD CODE TO GET MIN DISTANCE
		//float minDistance = DESphere(cameraRay.Origin);
		float minDistance = DETetraHedron(cameraRay.Origin);
		//float minDistance = DEBox(cameraRay.Origin, float3(2,2,2));
		//float2 sceneInfo = SceneInfo(cameraRay.Origin);
		//float minDistance = sceneInfo.y;

		if (minDistance < cameraRay.closestPoint) {cameraRay.closestPoint = minDistance;}

		float light;

		if (minDistance < epsilon)
		{
			//CODE WHEN RAY 'HITS' OBJECT
			hit = true;
			light =(float) numMarchSteps/ (float) maxNumMarchSteps;
			//light = marchDistance/ maxMarchDistance;
			//float light = 1;
			//light = EstimateNormalSphere(cameraRay.Origin,float3(0,0,0),float3(-1,0,0));
			Target[id.xy] = light* float4(1,0,0,0);

			break;
		}

		

		
		marchDistance += minDistance;
		cameraRay.Origin += cameraRay.Direction * minDistance;
	}

	if (!hit)
	{
		float4 Glow = (1 - cameraRay.closestPoint/.5 ) * float4(1,1,0,0);
		Target[id.xy] += Glow;
	}

	//ADD CODE TO WRITE OUTPUT PIXEL
}
