
#pragma kernel CSMain

// These are set from RayMarcher.cs /////////
Texture2D<float4> Source;
RWTexture2D<float4> Target;

float4x4 _CameraToWorldProj;
float4x4 _CameraInverseProj;

float4 _CameraPosition;
float4 _CameraRotation;
////////////////////////////////////////

static const float epsilon = 0.01;
static const float maxMarchDistance = 25;
static const int maxNumMarchSteps = 50;

float power = 1.5;

#include "Folds.hlsl"
#include "DistanceEstimators.hlsl"

struct Ray
{
	float3 Origin;
	float3 Direction;
	float closestPoint;
};

Ray CreateRay(float3 Origin, float3 Direction)
{
	Ray ray;

	ray.Origin = Origin;
	ray.Direction = Direction;
	ray.closestPoint = 100000;

	return ray;
}

Ray CreateCameraRay(float2 xy)
{
	//float3 Origin = mul(_CameraToWorldProj, float4(0,0,0,1)).xyz;
	float3 Origin = _CameraPosition.xyz;

    float3 Direction = mul(_CameraInverseProj, float4(xy,0,1)).xyz;
    Direction = mul(_CameraToWorldProj, float4(Direction,0)).xyz;
    Direction = normalize(Direction);

	return CreateRay(Origin,Direction);
}



float infiniteShapes(float3 Position)
{
	Position = ApplyAbsX(Position);
	Position = ApplyModX(Position,2);
	Position = ApplyAbsY(Position);
	Position = ApplyModY(Position, 2);
	Position = ApplyAbsZ(Position);
	Position = ApplyModZ(Position, 2);

	//return ApplyDETetra(Position, 0.5, float3(1, 1, 1));
	return ApplyDESphere(Position, 0.5, float3(1, 1, 1));
	//return ApplyDEBox(Position, float3(.5, .5, .5), float3(1, 1, 1));
}


float sierpinskiTetrahedron(float3 Position)
{
	float r;
	int n = 0;
	int Iterations = 10;
	float Scale = 2; 
	float3 Offset = float3(1, 1, 1);
	while (n < Iterations) {
		Position = ApplySierpinskiFold(Position);
		Position = ApplyScaleTranslate(Position, Scale, Offset);
		n++;
	}

	//float Distance = ApplyDESphere(Position, 1.0, float3(0, 0, 0));
	float Distance = ApplyDETetra(Position, 1.0, float3(0, 0, 0));
	//float Distance = ApplyDEBox(Position, float3(1,1,1), float3(1,1,1));

	return Distance * pow(Scale, -float(n));
}

float mandelBox(float3 Position)
{
	int n = 0;
	int Iterations = 16;

	while (n < Iterations) {		
		n++;
		Position = ApplyBoxFold(Position, 1);
		Position = ApplySphereFold(Position, .5, 1);
	}

	return ApplyDESphere(Position, 1, float3(1, 1, 1));
	//return ApplyDEBox(Position, float3(1, 1, 1), float3(1, 1, 1));
}

float snowStadium(float3 Position)
{
	int n = 0;
	int Iterations = 10;

	while (n < Iterations) {
		n++;


	}
}



float EstimateNormalSphere(float3 Position, float3 Center, float3 lightDirection)
{
	float3 Normal = Position - Center;
	return dot(Normal,lightDirection);
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	Target[id.xy] = Source[id.xy];

	uint width,height;
    Target.GetDimensions(width, height);

	float marchDistance = 0;
	int numMarchSteps = 0;

	//Convert from coordinates [-width,width] and [-heigth,height] to [-1,1] and [-1,1].
	float2 uv = id.xy / float2(width,height) * 2 - 1;

    Ray cameraRay = CreateCameraRay(uv);
	bool hit = false;

	Target[id.xy] = float4(0,1,1,0);

	while (marchDistance < maxMarchDistance && numMarchSteps < maxNumMarchSteps)
	{
		numMarchSteps++;

		float minDistance = sierpinskiTetrahedron(cameraRay.Origin);
		//float minDistance = infiniteShapes(cameraRay.Origin);
		//float minDistance = mandelBox(cameraRay.Origin);

		if (minDistance < cameraRay.closestPoint) {cameraRay.closestPoint = minDistance;}

		float light;

		if (minDistance < epsilon)
		{
			//CODE WHEN RAY 'HITS' OBJECT
			hit = true;
			light =(float) numMarchSteps/ (float) maxNumMarchSteps;
			//light = marchDistance/ maxMarchDistance;
			//light = 1;

			Target[id.xy] = light* float4(1,0,0,0);

			break;
		}
	
		marchDistance += minDistance;
		cameraRay.Origin += cameraRay.Direction * minDistance;
	}

	if (!hit)
	{
		float4 Glow = (1 - cameraRay.closestPoint/.5 ) * float4(1,1,0,0);
		Target[id.xy] += Glow;
	}

}
