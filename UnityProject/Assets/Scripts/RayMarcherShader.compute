
#pragma kernel CSMain
#pragma multi_compile __ CAST_SHADOWS
#pragma multi_compile __ LIT_SHADING
#pragma multi_compile __ AMBIENT_OCCLUSION
#pragma multi_compile __ GLOW

// These are set from RayMarcher.cs /////////
Texture2D<float4> Source;
RWTexture2D<float4> Target;

float4x4 _CameraToWorldProj;
float4x4 _CameraInverseProj;

float4 _CameraPosition;
float4 _CameraRotation;

float ambOccFudgeFactor;
float castShadowFactor;
////////////////////////////////////////

#include "Util.hlsl"
#include "Folds.hlsl"
#include "DistanceEstimators.hlsl"
#include "Fractals.hlsl"

static const float epsilon = 0.0001 / 1;
static const float maxMarchDistance = 1*250;
static const int maxNumMarchSteps = 1*250;


static const float3 lightDirection = normalize(float3(0.6, 0.5, 0.1));

struct Ray
{
	float3 Origin;
	float3 Direction;
	float closestPoint;
};

Ray CreateRay(float3 Origin, float3 Direction)
{
	Ray ray;

	ray.Origin = Origin;
	ray.Direction = Direction;
	ray.closestPoint = 100000;

	return ray;
}

Ray CreateCameraRay(float2 xy)
{
	//float3 Origin = mul(_CameraToWorldProj, float4(0,0,0,1)).xyz;
	float3 Origin = _CameraPosition.xyz;

    float3 Direction = mul(_CameraInverseProj, float4(xy,0,1)).xyz;
    Direction = mul(_CameraToWorldProj, float4(Direction,0)).xyz;
    Direction = normalize(Direction);

	return CreateRay(Origin,Direction);
}

// Set which fractal is going to be rendered.
float3 GetMinDistance(float3 Position)
{
	///// FUNCTIONAL FRACTALS ///////
	float minDistance = mengerBox(Position);
	//float minDistance = sierpinskiTetrahedron(Position);
	//float minDistance = infiniteShapes(Position);
	//////////////////////////////////

	//float minDistance = treePlanet(Position);
	//float minDistance = Mausoleum(Position);
	//float minDistance = butterweedHills(Position);
	//float minDistance = mandelBox(Position);

	return minDistance;
}

// Approximate normals by using central difference, source: https://www.iquilezles.org/www/articles/normalsSDF/normalsSDF.htm .
float3 ApproxNormal(float3 Position, float dx)
{
	float3 normalVec = float3(0, 0, 0);

	normalVec.x = GetMinDistance(Position + float3(dx, 0, 0));
	normalVec.x -= GetMinDistance(Position - float3(dx, 0, 0));

	normalVec.y = GetMinDistance(Position + float3(0, dx, 0));
	normalVec.y -= GetMinDistance(Position - float3(0, dx, 0));

	normalVec.z = GetMinDistance(Position + float3(0, 0, dx));
	normalVec.z -= GetMinDistance(Position - float3(0, 0, dx));
	
	return normalize(normalVec);
}

// Set what basecolour each pixel shoud start out with.
float4 GetColor(float3 Position)
{
	return float4(1,0,0,0);
	//return abs(float4(Position.x, Position.y, Position.z, 0))/10 + float4(.1,.1,.1,0);
}

// Main thread.
[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	Target[id.xy] = Source[id.xy];

	uint width,height;
    Target.GetDimensions(width, height);

	float marchDistance = 0;
	int numMarchSteps = 0;

	//Convert from coordinates [-width,width] and [-heigth,height] to [-1,1] and [-1,1].
	float2 uv = id.xy / float2(width,height) * 2 - 1;

    Ray cameraRay = CreateCameraRay(uv);
	bool hit = false;

	Target[id.xy] = float4(0,1,1,0);

	while (marchDistance < maxMarchDistance && numMarchSteps < maxNumMarchSteps)
	{
		numMarchSteps++;

		float minDistance = GetMinDistance(cameraRay.Origin);

		if (minDistance < cameraRay.closestPoint) {cameraRay.closestPoint = minDistance;}

		float light = 1;
		float lighting = 1;

		if (minDistance < epsilon)
		{
			hit = true;

#if AMBIENT_OCCLUSION
			light = 1 -  (float)numMarchSteps / ambOccFudgeFactor;
#endif

#if LIT_SHADING
			lighting = dot(ApproxNormal(cameraRay.Origin, 0.001),lightDirection);
#endif

			Target[id.xy] = light * lighting * GetColor(cameraRay.Origin); 
			
#if CAST_SHADOWS

			// Create a ray from the collision point to the light to check for occlusion.
			Ray lightRay = CreateRay(cameraRay.Origin - 10 * epsilon * cameraRay.Direction, lightDirection );

			float lightMarchDistance = 0;
			int ligthNumMarchSteps = 0;

			while (lightMarchDistance < maxMarchDistance && ligthNumMarchSteps < maxNumMarchSteps)
			{
				ligthNumMarchSteps++;

				float minLightDistance = GetMinDistance(lightRay.Origin);

				if (minLightDistance < epsilon)
				{
					Target[id.xy] *= castShadowFactor;
					break;
				}

				lightMarchDistance += minLightDistance;
				lightRay.Origin += lightRay.Direction * minLightDistance;
			}			
#endif
			break;
		}
	
		marchDistance += minDistance;
		cameraRay.Origin += cameraRay.Direction * minDistance;
	}

#if GLOW

	if (!hit)
	{
		float4 Glow = max((1 - cameraRay.closestPoint/.05 ) * float4(1,1,0,0), 0);
		Target[id.xy] += Glow;
	}
#endif

}
